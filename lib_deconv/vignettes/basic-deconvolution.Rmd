---
title: "Basic Deconvolution"
author: "Gregory Hunt"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Basic Deconvolution}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

We can show a basic deconvolution example by working with a data set created from rats. This is available on GEO with accession [GSE19830](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE19830).

First let's download the data set. 
```{r,warning=FALSE,cache=FALSE}
suppressPackageStartupMessages(library("affy"))
rat.url <- "ftp://ftp.ncbi.nlm.nih.gov/geo/series/GSE19nnn/GSE19830/suppl/GSE19830_RAW.tar"
rat.dir <- "rat_data"
dir.create(rat.dir, showWarnings = FALSE)
rat.file <- "rat.tar"
download.file(rat.url, destfile = rat.file)
untar(rat.file, exdir = rat.dir)
rat <- ReadAffy(celfile.path = rat.dir)
```

```{r,echo=FALSE,results='hide',cache=FALSE}
file.remove(rat.file)
file.remove(paste(rat.dir,dir(rat.dir),sep="/"))
unlink(rat.dir,force=TRUE,recursive=TRUE)
```

This is a data set of rat brain, liver and lung cells that have been mixed together in various proportions and then analyzed with by DNA microarrays. The true mixing proportions are encoded in the following matrix. 

```{r,cache=FALSE}
rat.truth = matrix(c(0,0,0,1,1,1,0,0,0,0.25,0.25,0.25,0.05,0.05,0.05,0.7,0.7,0.7,0.25,0.25,0.25,0.45,0.45,0.45,0.2,0.2,0.2,0.3,0.3,0.3,0.3,0.3,0.3,0.4,0.4,0.4,0.35,0.35,0.35,0.34,0.34,0.34,1,1,1,0,0,0,0,0,0,0.05,0.05,0.05,0.7,0.7,0.7,0.25,0.25,0.25,0.7,0.7,0.7,0.45,0.45,0.45,0.55,0.55,0.55,0.5,0.5,0.5,0.55,0.55,0.55,0.5,0.5,0.5,0.6,0.6,0.6,0.65,0.65,0.65,0,0,0,0,0,0,1,1,1,0.7,0.7,0.7,0.25,0.25,0.25,0.05,0.05,0.05,0.05,0.05,0.05,0.1,0.1,0.1,0.25,0.25,0.25,0.2,0.2,0.2,0.15,0.15,0.15,0.1,0.1,0.1,0.05,0.05,0.05,0.01,0.01,0.01),ncol=3,byrow=FALSE)
head(rat.truth)
```

Each row is a sample and each column gives the mixing proportions of the cell type. From this we can extract out the pure samples of each of the three cell types. 
```{r,cache=FALSE}
pure_samples <- lapply(1:3, function(i) {
    which(rat.truth[, i] == 1)
})
pure_samples
```

Now the deconvolution algorithm can work with many different types of data. Ultimately we just need a matrix of expressions for each experiment. Let's first look at the probe level data. 
```{r,results='hide',echo=FALSE,cache=FALSE}
library('affy')
```
```{r}
Y <- log2(t(affy::intensity(rat)))
Y[1:4,1:4]
```
Here each row is a different experiment and each column is the log expression measurement of a particular oligonucleotide. 

Given the data and the pure samples we can run our deconvolution algorithm. First let's run it blindly just supplying the expression matrix, the pure sample list and tell it how to set gamma based on the data type. 
```{r,cache=FALSE}
library('deconv')
dc <- deconv(Y, pure_samples,gamma='microarray-probe')
phats <- dc$estimates
head(phats)
```
We plot the estimated mixing proportions against the truth.

```{r,results='asis',fig.height=5,fig.width=5,cache=FALSE}
plot(rat.truth,phats,xlab="Truth",ylab="Estimates",xlim=c(0,1),ylim=c(0,1))
abline(coef=c(0,1))
```

There are a lot of arguments that can be supplied to the deconvolution function if desired. The three most important arguments are n_choose, full_markers and gamma. Instead of letting deconv adaptively compute these we can specify them in advance. Often it is useful to pre-compute the markers which allows us to test different values of the other arguemnts. 
```{r}
marker_list = find_markers(Y,pure_samples)
marks = marker_list$L
dc <- deconv(Y, pure_samples, n_choose = c(100,101,102), gamma=.6, full_markers = marks)
phats <- dc$estimates
head(phats)
dc <- deconv(Y, pure_samples, n_choose = 50, gamma = 1, full_markers = marks)
phats <- dc$estimates
head(phats)
```

One useful way to choose the number of markers is to threshold the value of the marker ranking algorithm.
```{r}
thresh = .01
K = length(pure_samples)
n_choose = sapply(1:K,function(i){max(which(marker_list$V[[i]] > (-thresh)))})
```

Doing this in advance often allows us to play with parameters without having to recompute them each time. 
```{r}
dc <- deconv(Y, pure_samples,n_choose,marks,gamma=1.1)
phats <- dc$estimates
plot(rat.truth,phats,xlab="Truth",ylab="Estimates",xlim=c(0,1),ylim=c(0,1))
abline(coef=c(0,1))
dc2 <- deconv(Y, pure_samples,n_choose,marks,gamma=.7)
phats2 <- dc2$estimates
points(rat.truth,phats2,col='blue')
dc3 <- deconv(Y, pure_samples,200,marks,gamma=.5)
phats3 <- dc3$estimates
points(rat.truth,phats3,col='red')
```

We can test different methods of choosing markers by specifying the ``marker_method`` argument.
```{r}
marker_list = find_markers(Y,pure_samples)
marks = marker_list$L
thresh = .01
K = length(pure_samples)
n_choose = sapply(1:K,function(i){max(which(marker_list$V[[i]] > (-thresh)))})

dc <- deconv(Y, pure_samples,gamma='microarray-probe',n_choose,marker_method = 'eta')
phats <- dc$estimates
plot(rat.truth,phats,xlab="Truth",ylab="Estimates",xlim=c(0,1),ylim=c(0,1))
abline(coef=c(0,1))

dc <- deconv(Y, pure_samples,n_choose,marker_method = 'diff',gamma='microarray-probe')
phats2 <- dc2$estimates
points(rat.truth,phats2,col='blue')

dc3 <- deconv(Y, pure_samples,n_choose,marker_method='regression',gamma='microarray-probe')
phats3 <- dc3$estimates
points(rat.truth,phats3,col='red')
```

We can also run the algorithm on RMA summarized expressions. 
```{r,warning=FALSE,results='hide',cache=FALSE}
Y <- data.frame(affy::rma(rat,verbose=FALSE))

dc <- deconv(Y, pure_samples,gamma="microarray-gene")
phats <- dc$estimates
```
We plot the estimated mixing proportions against the truth.

```{r,results='asis',fig.height=5,fig.width=5,cache=FALSE}
plot(rat.truth,phats,xlab="Truth",ylab="Estimates")
abline(coef=c(0,1))
```
