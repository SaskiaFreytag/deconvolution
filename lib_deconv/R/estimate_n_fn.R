#' Estimate expression sensivity parameter \code{gamma}. 
#' @param td The test data generated by \code{\link{gen_test_data}}. 
#' @param pure_samples The pure sample indicies. List of vectors. The i-th element of list is a vector of indicies (rows of data) that are pure samples of type i.
#' @param full_markers User supplied markers. List of vectors. List should be same length as \code{pure_samples}. Each element of list is vector of indicies (columns of Y) that will be considered markers of that particular type. Generated by \code{\link{find_markers}}.
#' @param gamma Expression sensitivity parameter. Single positive numeric. Can be determined by the function \code{\link{est_gamma}}.
#' @param curr_n Initial estimate of how many markers to use. Can either be a single integer or a vector of integers, one for each cell type. If a single integer then all cell types use that number of markers. 
#' @param n_reps Number of optimization iterations. Single integer.
#' @param err.plot Generate the plots of error by \code{n} used to select \code{n}.
#' @return Selected number of markers per cell type. Vector of integer. 
#' @export
est_n <- function(td, pure_samples, full_markers, gamma, curr_n, n_reps = 2, err.plot = FALSE) {
    K <- length(pure_samples)
    K <- length(pure_samples)
    
    for (j in 1:n_reps) {
        tmp_n <- rep(0, K)
        for (i in 1:K) {
            tmp_n[i] <- max_n(curr_n, td, pure_samples, full_markers, gamma, i, err.plot)
        }
        curr_n <- tmp_n
    }
    
    return(curr_n)
}

max_n <- function(curr_n, td, pure_samples, full_markers, gamma, k, err.plot = FALSE) {
    
    t_Y <- td$t_Y
    t_mix <- td$t_mix
    
    bottom_n <- ceiling(max(mean(curr_n[k]) - 500, 1))
    top_n <- ceiling(max(mean(curr_n[k]) + 500, 1))
    
    s <- seq(bottom_n, top_n, ceiling((top_n - bottom_n)/1000))
    elist <- array(0, c(6, length(s)))
    
    i <- 0
    for (n in s) {
        i <- i + 1
        n_choose <- curr_n
        n_choose[k] <- n
        dcnv <- deconv_res <- deconv(t_Y, pure_samples, n_choose, full_markers, gamma = gamma)$estimates
        err <- abs(dcnv - t_mix)
        
        dens_est <- approxfun(density(t_mix, from = 0, to = 1))
        de <- array(dens_est(t_mix), dim(t_mix))
        
        elist[, i] <- quantile(err/de, c(0.5, 0.6, 0.7, 0.8, 0.9, 1))
    }
    
    if (err.plot) 
        matplot(s, t(elist), main = paste(k), xlab = "n", ylab = "err", type = "l", 
            lwd = 3)
    
    m <- which.min(colMeans(elist))
    return(s[m])
}
