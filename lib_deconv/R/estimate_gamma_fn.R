#' Estimate expression sensivity parameter \code{gamma}. 
#' @param td The test data generated by \code{\link{gen_test_data}}. 
#' @param pure_samples The pure sample indicies. List of vectors. The i-th element of list is a vector of indicies (rows of data) that are pure samples of type i.
#' @param full_markers User supplied markers. List of vectors. List should be same length as \code{pure_samples}. Each element of list is vector of indicies (columns of Y) that will be considered markers of that particular type. Generated by \code{\link{find_markers}}.
#' @param curr_gamma Starting estimate of \code{gamma}.
#' @param n_choose How many markers to use. Can either be a single integer or a vector of integers, one for each cell type. If a single integer then all cell types use that number of markers. May be adaptively chosen using \code{\link{est_n}}.
#' @param n_reps Number of optimization iterations. Single integer.
#' @param err.plot Generate the plot of error by \code{gamma} used to select \code{gamma}.
#' @return The estimated sensivity parameter. Single positive numeric.
#' @export
est_gamma <- function(td, pure_samples, full_markers, curr_gamma, n_choose, n_reps = 2, 
    err.plot = FALSE) {
    for (j in 1:n_reps) {
        curr_gamma <- max_gamma(curr_gamma, td, pure_samples, full_markers, n_choose, 
            err.plot)
    }
    
    return(curr_gamma)
}

max_gamma <- function(curr_gamma, td, pure_samples, full_markers, n_choose, err.plot = FALSE) {
    
    t_Y <- td$t_Y
    t_mix <- td$t_mix
    
    bottom_g <- max(curr_gamma - 1, 0.1)
    top_g <- max(curr_gamma + 1, 0.1)
    
    s <- seq(bottom_g, top_g, (top_g - bottom_g)/1000)
    
    elist <- array(0, c(6, length(s)))
    
    i <- 0
    for (g in s) {
        i <- i + 1
        dcnv <- deconv_res <- deconv(t_Y, pure_samples, n_choose, full_markers, gamma = g)$estimates
        err <- abs(dcnv - t_mix)
        
        dens_est <- approxfun(density(t_mix, from = 0, to = 1))
        de <- array(dens_est(t_mix), dim(t_mix))
        
        elist[, i] <- quantile(err/de, c(0.5, 0.6, 0.7, 0.8, 0.9, 1))
    }
    
    if (err.plot) 
        matplot(s, t(elist), main = "", xlab = "gamma", ylab = "err", type = "l", 
            lwd = 3)
    
    m <- which.min(colMeans(elist))
    return(s[m])
}
